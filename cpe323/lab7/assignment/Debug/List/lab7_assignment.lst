###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         13/Oct/2014  18:00:08
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  D:\uah\cpe323\lab7\assignment\lab7_assignment.c
#    Command line  =  
#        D:\uah\cpe323\lab7\assignment\lab7_assignment.c -lCN
#        D:\uah\cpe323\lab7\assignment\Debug\List\ -o
#        D:\uah\cpe323\lab7\assignment\Debug\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430FG4618__ -e
#        --double=32 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\430\lib\dlib\dl430xlsfn.h" --core=430X
#        --data_model=small -On --multiplier=16 --segment __data16=DATA16
#        --segment __data20=DATA20 --code_model=large
#    List file     =  
#        D:\uah\cpe323\lab7\assignment\Debug\List\lab7_assignment.lst
#    Object file   =  
#        D:\uah\cpe323\lab7\assignment\Debug\Obj\lab7_assignment.r43
#
###############################################################################

D:\uah\cpe323\lab7\assignment\lab7_assignment.c
      1          /***********************************************************************
      2           * Title: Lab 7 Assignment
      3           * Date Due: Oct sometime
      4           * 
      5           * Description:
      6           * Here we will use Timer_B to modulate the output of Port 3.5 (TB4)
      7           * in order to drive an annoying-as-fuck speaker on the Exp Board!
      8           * The main idea is that you /must/ run both cap/comp 0 and 4. Cap/comp
      9           * 0 is used to drive the clock and TBCCR0 sets the max value for most
     10           * of the MCx settings, such as "UP" mode.
     11           * In order to make the calculations easier, I'm going to use 'toggle'
     12           * mode in this program, which means that TBCCR4 *doesn't matter* and
     13           * we can module the speaker directly with TBCCR0 :D
     14           * Also, we use watchdog for something, I think...
     15           *
     16           * By: Christopher 'ctag' Bero <csb0019@uah.edu>
     17           * Project: https://github.com/ctag/uah
     18           *
     19           * This software is licensed under the GPLv3,
     20           * consult the LICENSE file for more information.
     21           **********************************************************************/
     22          
     23          #include <msp430.h> // The *correct* include statement

   \                                 In  segment DATA16_AN, at 0x0
   \   unsigned char volatile IE1
   \                     IE1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1a
   \   unsigned char volatile P3DIR
   \                     P3DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b
   \   unsigned char volatile P3SEL
   \                     P3SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x180
   \   unsigned short volatile TBCTL
   \                     TBCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x18a
   \   unsigned short volatile TBCCTL4
   \                     TBCCTL4:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x192
   \   unsigned short volatile TBCCR0
   \                     TBCCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x19a
   \   unsigned short volatile TBCCR4
   \                     TBCCR4:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2
     24          
     25          #define SW1 0x01&P1IN	// B1 - P1.0 switch SW1 
     26          #define SW2 0x02&P1IN	// B2 - P1.1 switch SW2
     27          
     28          #define LED1 BIT2; // LED1 - P2.2 - 0x04
     29          #define LED2 BIT1; // LED2 - P2.1 - 0x02
     30          
     31          // Usage: WDTCTL = WDT_CONFIG;
     32          #define WDT_CONFIG (WDTPW|WDTCNTCL|WDTSSEL) // Set bits to give us 1s watchdog
     33          #define WDT_INTERVAL (WDTPW|WDTCNTCL|WDTTMSEL|WDTSSEL|WDTIS0) // Set bits to have a 1s timer
     34          #define WDT_HALT (WDTPW|WDTHOLD) // Set bits to halt the timer
     35          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          short unsigned int new_note_flag = 0;
   \                     new_note_flag:
   \   000000                DS8 2
     37          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     38          double freq[] = {440.00, 493.88, 523.25, 587.33, 659.25, 698.46, 783.99};
   \                     freq:
   \   000000                DS8 28
   \   00001C                REQUIRE `?<Initializer for freq>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     39          char notes[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
   \                     notes:
   \   000000                DS8 7
   \   000007                REQUIRE `?<Initializer for notes>`
     40          

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     41          char mysong[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
   \                     mysong:
   \   000000                DS8 7
   \   000007                REQUIRE `?<Initializer for mysong>`
     42          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     43          int index = 0;
   \                     index:
   \   000000                DS8 2
     44          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     45          int notes_len = 7;
   \                     notes_len:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for notes_len>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     46          int mysong_len = 7;
   \                     mysong_len:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for mysong_len>`
     47          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     48          char note;
   \                     note:
   \   000000                DS8 1
     49          

   \                                 In  segment CODE, align 2
     50          void main(void)
   \                     main:
     51          {
     52          	WDTCTL = WDT_INTERVAL;
   \   000000   B2401D5A2001 MOV.W   #0x5a1d, &0x120
     53          	IE1 |= BIT0; // BIT0 is WDTIE
   \   000006   D2D30000     BIS.B   #0x1, &0x0
     54          	__enable_interrupt();
   \   00000A   32D2         EINT
     55          	
     56          	P3DIR |= BIT5; // Set P3.5 to OUT
   \   00000C   F2D020001A00 BIS.B   #0x20, &0x1a
     57          	P3SEL |= BIT5; // Setup the special TB4 function of P3.5
   \   000012   F2D020001B00 BIS.B   #0x20, &0x1b
     58          	
     59          	/* // Setup Timer_B's TBCTL
     60          	// BITs Mapping for TxCTLx:
     61          	//	[15]	[14]	[13]	[12]	[11]	[10]	[9]		[8]
     62          	//	NA		NA		NA		NA		NA		NA		TASSEL	TASSEL
     63          	//	0		0		0		0		0		0		0		1
     64          	//
     65          	//	[7]		[6]		[5]		[4]		[3]		[2]		[1]		[0]
     66          	//	ID		ID		MC		MC		NA		TACLR	TAIE	TAIFG
     67          	//	0		1		0		1		0		0		0		0
     68          	//
     69          	// Condensed: [0000][0001] [0101][0000]
     70          	//
     71          	// Specifics:
     72          	// TASSELx = 01, ACLK
     73          	// IDx = 01, divide ACLK by 2, ACLK/2 = 16,384
     74          	// MCx = 01, UP mode
     75          	*/
     76          	TBCTL = 0x0150;
   \   000018   B24050018001 MOV.W   #0x150, &0x180
     77          	
     78          	/* // Choosing a value for TBCCR0:
     79          	// This is a little tricky, because you can tackle this problem
     80          	// from a multitude of angles, and the one I chose is likely non-standard,
     81          	// but makes much more sense to me.
     82          	// So, TBCCR0 represents the period out of 16,384 which we wish
     83          	// for the speaker to be pulsed each second. A value of 16,384 means
     84          	// the speaker will click once per second. A value of 16 means the
     85          	// speaker will click about 1000 times per second, which is an audible tone!
     86          	//
     87          	// The formula:
     88          	// TBCCR0 = [ACLK = 16384] / [desired freq in Hz]
     89          	//
     90          	// So, for 900Hz, TBCCR0 = [16384] / [900] = 18.2 = 18.
     91          	*/
     92          	TBCCR0 = 19;
   \   00001E   B24013009201 MOV.W   #0x13, &0x192
     93          	
     94          	/* // Setup Timer_B's TBCCTL4
     95          	// BITs Mapping for TxCTLx:
     96          	//	[15]	[14]	[13]	[12]	[11]	[10]	[9]		[8]
     97          	//	CM		CM		CCIS	CCIS	SCS		CCLD	CCLD	CAP
     98          	//	0		0		0		0		0		0		0		0
     99          	//
    100          	//	[7]		[6]		[5]		[4]		[3]		[2]		[1]		[0]
    101          	//	OUTMOD	OUTMOD	OUTMOD	CCIE	CCI		OUT		COV		CCIFG
    102          	//	1		0		0		0		0		0		0		0
    103          	//
    104          	// Condensed: [0000][0000] [1000][0000]
    105          	//
    106          	// Specifics:
    107          	// OUTx = 100, Toggle mode (on TB4 of course) 
    108          	*/
    109          	TBCCTL4 = 0x0080;
   \   000024   B24080008A01 MOV.W   #0x80, &0x18a
    110          	
    111          	TBCCR4 = 1; // doesn't matter, can be any valid value
   \   00002A   92439A01     MOV.W   #0x1, &0x19a
    112          	
    113          	while (1)
    114          	{
    115          		while (new_note_flag == 0)
   \                     ??main_1:
   \   00002E   8293....     CMP.W   #0x0, &new_note_flag
   \   000032   0220         JNE     ??main_3
    116          		{
    117          			asm("NOP");
   \   000034   0343         NOP
   \   000036   FB3F         JMP     ??main_1
    118          		}
    119          		new_note_flag = 0;
   \                     ??main_3:
   \   000038   8243....     MOV.W   #0x0, &new_note_flag
    120          		
    121          		for (int i = 0; i < notes_len; i++)
   \   00003C   0F43         MOV.W   #0x0, R15
   \                     ??main_2:
   \   00003E   1F92....     CMP.W   &notes_len, R15
   \   000042   F537         JGE     ??main_1
    122          		{
    123          			if (notes[i] == note)
   \   000044   DF92........ CMP.B   &note, notes(R15)
   \   00004A   0F20         JNE     ??main_4
    124          			{
    125          				TBCCR0 = (16384 / freq[i]);
   \   00004C   5F06         RLAM.W  #0x2, R15
   \   00004E   1E4F....     MOV.W   freq(R15), R14
   \   000052   1F4F....     MOV.W   freq + 2(R15), R15
   \   000056   0C43         MOV.W   #0x0, R12
   \   000058   3D408046     MOV.W   #0x4680, R13
   \   00005C   ........     CALLA   #_Div32f
   \   000060   ........     CALLA   #_Cast32fto32u
   \   000064   824C9201     MOV.W   R12, &0x192
    126          				break;
   \   000068   E23F         JMP     ??main_1
    127          			}
    128          		}
   \                     ??main_4:
   \   00006A   1F53         ADD.W   #0x1, R15
   \   00006C   E83F         JMP     ??main_2
   \   00006E                REQUIRE WDTCTL
   \   00006E                REQUIRE IE1
   \   00006E                REQUIRE P3DIR
   \   00006E                REQUIRE P3SEL
   \   00006E                REQUIRE TBCTL
   \   00006E                REQUIRE TBCCR0
   \   00006E                REQUIRE TBCCTL4
   \   00006E                REQUIRE TBCCR4
    129          		
    130          		
    131          	}
    132          }
    133          
    134          #pragma vector = WDT_VECTOR

   \                                 In  segment ISR_CODE, align 2
    135          __interrupt void blink_watchdog(void)
   \                     blink_watchdog:
    136          {
   \   000000   0F12         PUSH.W  R15
    137          	new_note_flag = 1;
   \   000002   9243....     MOV.W   #0x1, &new_note_flag
    138          	index ++;
   \   000006   9253....     ADD.W   #0x1, &index
    139          	if (index == mysong_len)
   \   00000A   9292........ CMP.W   &mysong_len, &index
   \   000010   0220         JNE     ??blink_watchdog_0
    140          	{
    141          		index = 0;
   \   000012   8243....     MOV.W   #0x0, &index
    142          	}
    143          	note = mysong[index];
   \                     ??blink_watchdog_0:
   \   000016   1F42....     MOV.W   &index, R15
   \   00001A   D24F........ MOV.B   mysong(R15), &note
    144          }
   \   000020   3F41         POP.W   R15
   \   000022   0013         RETI

   \                                 In  segment INTVEC, offset 0x34, root
   \                     `??blink_watchdog??INTVEC 52`:
   \   000034   ....         DC16    blink_watchdog

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for freq>`:
   \   000000   0000DC43A4F0 DC32 43DC0000H, 43F6F0A4H, 4402D000H, 4412D51FH, 4424D000H, 442E9D71H
   \            F64300D00244
   \            1FD5124400D0
   \            2444719D2E44
   \   000018   5CFF4344     DC32 4443FF5CH

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for notes>`:
   \   000000   414243444546 DC8 65, 66, 67, 68, 69, 70, 71
   \            47          

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for mysong>`:
   \   000000   414243444546 DC8 65, 66, 67, 68, 69, 70, 71
   \            47          

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for notes_len>`:
   \   000000   0700         DC16 7

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for mysong_len>`:
   \   000000   0700         DC16 7
    145          
    146          
    147          
    148          
    149          
    150          
    151          
    152          
    153          
    154          
    155          
    156          
    157          
    158          
    159          
    160          
    161          
    162          
    163          
    164          
    165          
    166          
    167          
    168          
    169          
    170          
    171          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   blink_watchdog
      4   main
        4   -> _Cast32fto32u
        4   -> _Div32f


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      28  ?<Initializer for freq>
       7  ?<Initializer for mysong>
       2  ?<Initializer for mysong_len>
       7  ?<Initializer for notes>
       2  ?<Initializer for notes_len>
       2  ??blink_watchdog??INTVEC 52
       1  IE1
       1  P3DIR
       1  P3SEL
       2  TBCCR0
       2  TBCCR4
       2  TBCCTL4
       2  TBCTL
       2  WDTCTL
      36  blink_watchdog
      28  freq
       2  index
     110  main
       7  mysong
       2  mysong_len
       2  new_note_flag
       1  note
       7  notes
       2  notes_len

 
 110 bytes in segment CODE
  13 bytes in segment DATA16_AN
  46 bytes in segment DATA16_I
  46 bytes in segment DATA16_ID
   5 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
  36 bytes in segment ISR_CODE
 
 146 bytes of CODE  memory
  46 bytes of CONST memory (+  2 bytes shared)
  51 bytes of DATA  memory (+ 13 bytes shared)

Errors: none
Warnings: 1
