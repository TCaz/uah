###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         01/Oct/2014  16:12:35
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  D:\uah\cpe323\lab6\assignment\lab6_bero.c
#    Command line  =  
#        D:\uah\cpe323\lab6\assignment\lab6_bero.c -lCN
#        D:\uah\cpe323\lab6\assignment\Debug\List\ -o
#        D:\uah\cpe323\lab6\assignment\Debug\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430FG4618__ -e
#        --double=32 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\430\lib\dlib\dl430xlsfn.h" --core=430X
#        --data_model=small -On --multiplier=16 --segment __data16=DATA16
#        --segment __data20=DATA20 --code_model=large
#    List file     =  D:\uah\cpe323\lab6\assignment\Debug\List\lab6_bero.lst
#    Object file   =  D:\uah\cpe323\lab6\assignment\Debug\Obj\lab6_bero.r43
#
###############################################################################

D:\uah\cpe323\lab6\assignment\lab6_bero.c
      1          /**********************************************************************
      2           *   lab6, TI experimenter board project
      3           *
      4           *   Desc:	This program closely follows the guidelines set for
      5           *			it in the Lab6 pdf manual.
      6           *			SW1 and SW2 are interrupt enabled and each affects
      7           * 			the controller's clock to adjust the blink rate of LED1&2
      8           *
      9           *           [MSP430xG461x]
     10           *     .   .-------._.-------.
     11           *    /|\  |                 |
     12           *     |   |                 |
     13           *     `---|RST              |
     14           *         |            P1.0 |-->SW1 (labeled)
     15           *         |            P1.1 |-->SW2 (labeled)
     16           *         |                 |
     17           *         |            P2.2 |-->LED1 (GREEN)
     18           *         |            P2.1 |-->LED2 (YELLOW)
     19           *         \_________________/   
     20           * 
     21           *   Christopher Bero <csb0019@uah.edu>
     22           **********************************************************************/
     23          
     24          #include  <msp430.h> 	// The /correct/ way to include standard library

   \                                 In  segment DATA16_AN, at 0x50
   \   unsigned char volatile SCFI0
   \                     SCFI0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x52
   \   unsigned char volatile SCFQCTL
   \                     SCFQCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x53
   \   unsigned char volatile FLL_CTL0
   \                     FLL_CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x20
   \   unsigned char const volatile P1IN
   \                     P1IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x24
   \   unsigned char volatile P1IES
   \                     P1IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x25
   \   unsigned char volatile P1IE
   \                     P1IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x29
   \   unsigned char volatile P2OUT
   \                     P2OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x160
   \   unsigned short volatile TACTL
   \                     TACTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x162
   \   unsigned short volatile TACCTL0
   \                     TACCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x172
   \   unsigned short volatile TACCR0
   \                     TACCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2
     25          
     26          #define SW1 0x01&P1IN	// B1 - P1.0 switch SW1 
     27          #define SW2 0x02&P1IN	// B2 - P1.1 switch SW2
     28          
     29          // Volatile variables may be changed at any time by a subroutine (interrupt)

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          volatile int timerCount = 0;			// Number of times TimerA has been triggered
   \                     timerCount:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     31          volatile int previousClock = 60;		// The clock factor to return to after SW2 interrupt
   \                     previousClock:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for previousClock>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     32          volatile short int sw2Interrupt = 0;	// Status boolean, are we in a modified clock state?
   \                     sw2Interrupt:
   \   000000                DS8 2
     33          										// 0 = no; 1 = yes;
     34          /*
     35           * Main function (infinite loop, no exit)
     36           */

   \                                 In  segment CODE, align 2
     37          void main ( void ) 
   \                     main:
     38          {
     39          	WDTCTL = WDTPW + WDTHOLD;	// Stop watchdog timer 
   \   000000   B240805A2001 MOV.W   #0x5a80, &0x120
     40          
     41          	FLL_CTL0 |= XCAP18PF;	// Set load capacitance for xtal
   \   000006   F2D030005300 BIS.B   #0x30, &0x53
     42          	SCFI0 |= FN_2;			// x2 DCO, 4MHz nominal DCO
   \   00000C   E2D25000     BIS.B   #0x4, &0x50
     43          	SCFQCTL = 60;			// (60+1) x 32768 ~~ 2 MHz
   \   000010   F2403C005200 MOV.B   #0x3c, &0x52
     44          	
     45          	P2DIR |= 0x06; 		    // Set P2.1 and P2.2 to output direction (0000_0110) 
   \   000016   F2D006002A00 BIS.B   #0x6, &0x2a
     46          	P2OUT = 0x02; 		// Set P2OUT to 0000_0010b (LED2 is ON, LED1 is OFF)
   \   00001C   E2432900     MOV.B   #0x2, &0x29
     47          	
     48          	// Screw looping, I'm using TimerA to control LEDs
     49          	TA0CCR0 |= 40000-1;		// See below
   \   000020   B2D03F9C7201 BIS.W   #0x9c3f, &0x172
     50          		// ACLK ~ 33KHz & SMCLK ~ 2MHz
     51          		// So we trigger every 32,768 clicks to achieve 1Hz blink (1 second on, 1 second off) with ACLK
     52          		// Or every 2,000,000 clicks for SMCLK (the one we have to use)
     53          		// The register value cannot exceed ~60,000, so we must use 40,000 and count to 50
     54          		// But we really want a 2Hz blink (0.5 sec on, 0.5 sec off), so we only count to 25
     55          	TA0CCTL0 |= CCIE;			// Enable the clock interrupt
   \   000026   B2D010006201 BIS.W   #0x10, &0x162
     56          	TA0CTL |= TASSEL_2 + MC_1;	// Choose SMCLK as the clock, change to TASSEL_1 for ACLK	
   \   00002C   B2D010026001 BIS.W   #0x210, &0x160
     57          
     58          	_EINT();				// Enable interrupts
   \   000032   32D2         EINT
     59          	P1IE |= 0x0003;			// P1.0 interrupt enabled
   \   000034   F2D003002500 BIS.B   #0x3, &0x25
     60          	P1IES |= 0x0003;		// P1.0 hi -> low edge
   \   00003A   F2D003002400 BIS.B   #0x3, &0x24
     61          	P1IFG &= ~0x0003;		// Clear P1.0 IFG
   \   000040   F2F0FC002300 AND.B   #0xfc, &0x23
     62          	
     63          	while (1) 
     64          	{
     65          		// Comming out of a SW2 interrupt once button is released
     66          		if (((SW2) != 0) && (sw2Interrupt == 1))
   \                     ??main_0:
   \   000046   E2B32000     BIT.B   #0x2, &0x20
   \   00004A   FD2B         JNC     ??main_0
   \   00004C   9293....     CMP.W   #0x1, &sw2Interrupt
   \   000050   FA23         JNE     ??main_0
     67          		{
     68          			SCFQCTL = previousClock;
   \   000052   1E42....     MOV.W   &previousClock, R14
   \   000056   C24E5200     MOV.B   R14, &0x52
     69          			sw2Interrupt = 0;
   \   00005A   8243....     MOV.W   #0x0, &sw2Interrupt
   \   00005E   F33F         JMP     ??main_0
   \   000060                REQUIRE WDTCTL
   \   000060                REQUIRE FLL_CTL0
   \   000060                REQUIRE SCFI0
   \   000060                REQUIRE SCFQCTL
   \   000060                REQUIRE P2DIR
   \   000060                REQUIRE P2OUT
   \   000060                REQUIRE TACCR0
   \   000060                REQUIRE TACCTL0
   \   000060                REQUIRE TACTL
   \   000060                REQUIRE P1IE
   \   000060                REQUIRE P1IES
   \   000060                REQUIRE P1IFG
   \   000060                REQUIRE P1IN
     70          		}
     71          	}
     72          
     73          }
     74          
     75          /*
     76           * Port 1 interrupt service
     77           */
     78          #pragma vector = PORT1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     79          __interrupt void Port1_ISR (void)
   \                     Port1_ISR:
     80          {
   \   000000   3F15         PUSHM.W #0x4, R15
     81            // Constant delay debounce, arbitrarily chosen values, revise later
     82            int factor = (SCFQCTL / 30);
   \   000002   5C425200     MOV.B   &0x52, R12
   \   000006   7E401E00     MOV.B   #0x1e, R14
   \   00000A   ........     CALLA   #?DivMod8u
   \   00000E   4C4C         MOV.B   R12, R12
     83            int looper = (50 * factor);
   \   000010   0E4C         MOV.W   R12, R14
   \   000012   0E5E         RLA.W   R14
   \   000014   0F4E         MOV.W   R14, R15
   \   000016   5E0A         RLAM.W  #0x3, R14
   \   000018   0F5E         ADD.W   R14, R15
   \   00001A   0E5E         RLA.W   R14
   \   00001C   0E5F         ADD.W   R15, R14
     84            
     85            for (int c = 0; c < looper; c++)
   \   00001E   0F43         MOV.W   #0x0, R15
   \                     ??Port1_ISR_0:
   \   000020   0F9E         CMP.W   R14, R15
   \   000022   0334         JGE     ??Port1_ISR_1
     86            {
     87              asm("NOP");
   \   000024   0343         NOP
     88            }
   \   000026   1F53         ADD.W   #0x1, R15
   \   000028   FB3F         JMP     ??Port1_ISR_0
     89            
     90          	if (((SW1) == 0) && ((SW2) != 0))
   \                     ??Port1_ISR_1:
   \   00002A   D2B32000     BIT.B   #0x1, &0x20
   \   00002E   122C         JC      ??Port1_ISR_2
   \   000030   E2B32000     BIT.B   #0x2, &0x20
   \   000034   0F28         JNC     ??Port1_ISR_2
     91          	{
     92          		if (SCFQCTL == 60)
   \   000036   F2903C005200 CMP.B   #0x3c, &0x52
   \   00003C   0420         JNE     ??Port1_ISR_3
     93          		{
     94          			SCFQCTL = 120;			// Set clock to 4Mhz
   \   00003E   F24078005200 MOV.B   #0x78, &0x52
   \   000044   073C         JMP     ??Port1_ISR_2
     95          		} 
     96          		else if (SCFQCTL == 120)
   \                     ??Port1_ISR_3:
   \   000046   F29078005200 CMP.B   #0x78, &0x52
   \   00004C   0320         JNE     ??Port1_ISR_2
     97          		{
     98          			SCFQCTL = 60;			// Set clock to 2Mhz
   \   00004E   F2403C005200 MOV.B   #0x3c, &0x52
     99          		}
    100          	}
    101          	
    102          	if (((SW2) == 0) && ((SW1) != 0) && (sw2Interrupt == 0))
   \                     ??Port1_ISR_2:
   \   000054   E2B32000     BIT.B   #0x2, &0x20
   \   000058   102C         JC      ??Port1_ISR_4
   \   00005A   D2B32000     BIT.B   #0x1, &0x20
   \   00005E   0D28         JNC     ??Port1_ISR_4
   \   000060   8293....     CMP.W   #0x0, &sw2Interrupt
   \   000064   0A20         JNE     ??Port1_ISR_4
    103          	{
    104          		previousClock = SCFQCTL;
   \   000066   5F425200     MOV.B   &0x52, R15
   \   00006A   4F4F         MOV.B   R15, R15
   \   00006C   824F....     MOV.W   R15, &previousClock
    105          		sw2Interrupt = 1;
   \   000070   9243....     MOV.W   #0x1, &sw2Interrupt
    106                          
    107          		SCFQCTL = 30;		// Set clock to 1Mhz
   \   000074   F2401E005200 MOV.B   #0x1e, &0x52
    108          	}
    109          		P1IFG &= ~BIT1;		// Clear P1.0 IFG
   \                     ??Port1_ISR_4:
   \   00007A   E2C32300     BIC.B   #0x2, &0x23
    110          		P1IFG &= ~BIT0;		// Clear P1.0 IFG
   \   00007E   D2C32300     BIC.B   #0x1, &0x23
    111          }
   \   000082   3C17         POPM.W  #0x4, R15
   \   000084   0013         RETI
   \   000086                REQUIRE SCFQCTL
   \   000086                REQUIRE P1IN
   \   000086                REQUIRE P1IFG
    112          
    113          /*
    114           * TimerA interrupt service
    115           */
    116          #pragma vector=TIMER0_A0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    117          __interrupt void Timer0_A0 (void) 
   \                     Timer0_A0:
    118          {
    119          	timerCount++;
   \   000000   9253....     ADD.W   #0x1, &timerCount
    120          	
    121          	if (timerCount == 25)
   \   000004   B2901900.... CMP.W   #0x19, &timerCount
   \   00000A   0520         JNE     ??Timer0_A0_0
    122          	{
    123          		P2OUT ^= 0x06;
   \   00000C   F2E006002900 XOR.B   #0x6, &0x29
    124          		timerCount = 0;
   \   000012   8243....     MOV.W   #0x0, &timerCount
    125          	}
    126          }
   \                     ??Timer0_A0_0:
   \   000016   0013         RETI
   \   000018                REQUIRE P2OUT

   \                                 In  segment INTVEC, offset 0x28, root
   \                     `??Port1_ISR??INTVEC 40`:
   \   000028   ....         DC16    Port1_ISR

   \                                 In  segment INTVEC, offset 0x2c, root
   \                     `??Timer0_A0??INTVEC 44`:
   \   00002C   ....         DC16    Timer0_A0

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for previousClock>`:
   \   000000   3C00         DC16 60
    127          
    128          /*****************
    129           * General Notes
    130           *****************
    131           * Idea:
    132           * Create project which expoits the 90 ms brain delay
    133           * 
    134           * Make sure to encapsulate comparisons with () when using && + ||
    135           * 
    136           */
    137          
    138          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   Port1_ISR
      4   Timer0_A0
      4   main


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for previousClock>
       2  ??Port1_ISR??INTVEC 40
       2  ??Timer0_A0??INTVEC 44
       1  FLL_CTL0
       1  P1IE
       1  P1IES
       1  P1IFG
       1  P1IN
       1  P2DIR
       1  P2OUT
     134  Port1_ISR
       1  SCFI0
       1  SCFQCTL
       2  TACCR0
       2  TACCTL0
       2  TACTL
      24  Timer0_A0
       2  WDTCTL
      96  main
       2  previousClock
       2  sw2Interrupt
       2  timerCount

 
  96 bytes in segment CODE
  17 bytes in segment DATA16_AN
   2 bytes in segment DATA16_I
   2 bytes in segment DATA16_ID
   4 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 158 bytes in segment ISR_CODE
 
 254 bytes of CODE  memory
   2 bytes of CONST memory (+  4 bytes shared)
   6 bytes of DATA  memory (+ 17 bytes shared)

Errors: none
Warnings: none
