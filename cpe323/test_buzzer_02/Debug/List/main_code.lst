###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         08/Oct/2014  17:11:54
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  D:\uah\cpe323\test_buzzer_02\main_code.c
#    Command line  =  
#        D:\uah\cpe323\test_buzzer_02\main_code.c -lCN
#        D:\uah\cpe323\test_buzzer_02\Debug\List\ -o
#        D:\uah\cpe323\test_buzzer_02\Debug\Obj\ --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --debug -D__MSP430FG4618__ -e
#        --double=32 --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\430\lib\dlib\dl430xlsfn.h" --core=430X
#        --data_model=small -On --multiplier=16 --segment __data16=DATA16
#        --segment __data20=DATA20 --code_model=large
#    List file     =  D:\uah\cpe323\test_buzzer_02\Debug\List\main_code.lst
#    Object file   =  D:\uah\cpe323\test_buzzer_02\Debug\Obj\main_code.r43
#
###############################################################################

D:\uah\cpe323\test_buzzer_02\main_code.c
      1          /***********************************************************************
      2           * Title: TEST: Buzzer 02
      3           * Date Due: NEVAR!
      4           * 
      5           * Description:
      6           * This program will test the buzzer.
      7           *
      8           * By: Christopher 'ctag' Bero <csb0019@uah.edu>
      9           * Project: https://github.com/ctag/uah
     10           *
     11           * This software is licensed under the GPLv3,
     12           * consult the LICENSE file for more information.
     13           **********************************************************************/
     14          
     15          #include <msp430.h> // The *correct* include statement

   \                                 In  segment DATA16_AN, at 0x52
   \   unsigned char volatile SCFQCTL
   \                     SCFQCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x20
   \   unsigned char const volatile P1IN
   \                     P1IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1a
   \   unsigned char volatile P3DIR
   \                     P3DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b
   \   unsigned char volatile P3SEL
   \                     P3SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x180
   \   unsigned short volatile TBCTL
   \                     TBCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x18a
   \   unsigned short volatile TBCCTL4
   \                     TBCCTL4:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x19a
   \   unsigned short volatile TBCCR4
   \                     TBCCR4:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2
     16          
     17          #define SW1 0x01&P1IN	// B1 - P1.0 switch SW1 
     18          #define SW2 0x02&P1IN	// B2 - P1.1 switch SW2
     19          

   \                                 In  segment CODE, align 2
     20          void main(void)
   \                     main:
     21          {
     22          	//WDTCTL = WDT_ADLY_250;	// 1 s interval timer
     23          	WDTCTL = (WDTPW|WDTHOLD);
   \   000000   B240805A2001 MOV.W   #0x5a80, &0x120
     24          	
     25          	P3DIR |= BIT5; // Set P3.5 to OUT
   \   000006   F2D020001A00 BIS.B   #0x20, &0x1a
     26          	P3SEL |= BIT5; // Setup the special TB4 function of P3.5
   \   00000C   F2D020001B00 BIS.B   #0x20, &0x1b
     27          	
     28          	//_EINT();			// Enable interrupts
     29          	// __enable_interrupt(); // Same as _EINT()?
     30          	
     31          	//IE1 |= WDTIE;                     // Enable WDT interrupt
     32          	//_BIS_SR(LPM0_bits + GIE);         // Enter LPM0 w/ interrupt
     33          	
     34          	// Setup Timer_B
     35          	TBCTL = 0x0157;
   \   000012   B24057018001 MOV.W   #0x157, &0x180
     36          	// ACLK = 32,768Hz
     37          	// We want something more like 10,000Hz, so divide ACLK to as close to 3 as possible?
     38          	// Hence, IDx (input divider) is set to 2 (01), IDx=01;
     39          	// MCx = 01, Up mode.
     40          	
     41          	// Setup TBCCTLx
     42          	TBCCTL4 = 0x0060;
   \   000018   B24060008A01 MOV.W   #0x60, &0x18a
     43          	// OUTMODx = 011
     44          	
     45          	TBCCR4 = 0x8000; // ~700Hz?
   \   00001E   B24000809A01 MOV.W   #0x8000, &0x19a
     46          	
     47          	
     48          	while (1)
     49          	{
     50          		asm("NOP");
   \                     ??main_0:
   \   000024   0343         NOP
   \   000026   FE3F         JMP     ??main_0
   \   000028                REQUIRE WDTCTL
   \   000028                REQUIRE P3DIR
   \   000028                REQUIRE P3SEL
   \   000028                REQUIRE TBCTL
   \   000028                REQUIRE TBCCTL4
   \   000028                REQUIRE TBCCR4
     51          	}
     52          }
     53          
     54          /*
     55           * Watchdog Timer interrupt service routine
     56           */
     57          #pragma vector = WDT_VECTOR

   \                                 In  segment ISR_CODE, align 2
     58          __interrupt void watchdog_timer(void)
   \                     watchdog_timer:
     59          {
     60          
     61          }
   \   000000   0013         RETI
     62          
     63          /*
     64           * Port 1 interrupt service routine
     65           */
     66          #pragma vector = PORT1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     67          __interrupt void Port1_ISR (void)
   \                     Port1_ISR:
     68          {
   \   000000   3F15         PUSHM.W #0x4, R15
     69          	// Constant delay debounce
     70          	int factor = (SCFQCTL / 30);
   \   000002   5C425200     MOV.B   &0x52, R12
   \   000006   7E401E00     MOV.B   #0x1e, R14
   \   00000A   ........     CALLA   #?DivMod8u
   \   00000E   4C4C         MOV.B   R12, R12
     71          	int looper = (20 * factor);
   \   000010   0F4C         MOV.W   R12, R15
   \   000012   5F06         RLAM.W  #0x2, R15
   \   000014   0E4F         MOV.W   R15, R14
   \   000016   5F06         RLAM.W  #0x2, R15
   \   000018   0F5E         ADD.W   R14, R15
     72          	for (int c = 0; c < looper; c++)
   \   00001A   0E43         MOV.W   #0x0, R14
   \                     ??Port1_ISR_0:
   \   00001C   0E9F         CMP.W   R15, R14
   \   00001E   0334         JGE     ??Port1_ISR_1
     73          	{ asm("NOP"); }
   \   000020   0343         NOP
   \   000022   1E53         ADD.W   #0x1, R14
   \   000024   FB3F         JMP     ??Port1_ISR_0
     74          
     75          	if (((SW1) == 0) && ((SW2) != 0)) // SW1 is pressed
   \                     ??Port1_ISR_1:
   \   000026   D2B32000     BIT.B   #0x1, &0x20
   \   00002A   032C         JC      ??Port1_ISR_2
   \   00002C   E2B32000     BIT.B   #0x2, &0x20
   \   000030   052C         JC      ??Port1_ISR_3
     76          	{
     77          	
     78          	} else if (((SW2) == 0) && ((SW1) != 0)) // SW2 is pressed
   \                     ??Port1_ISR_2:
   \   000032   E2B32000     BIT.B   #0x2, &0x20
   \   000036   022C         JC      ??Port1_ISR_3
   \   000038   5E422000     MOV.B   &0x20, R14
     79          	{
     80          	
     81          	}
     82          
     83          	P1IFG &= ~BIT1;		// Clear P1.1 IFG
   \                     ??Port1_ISR_3:
   \   00003C   E2C32300     BIC.B   #0x2, &0x23
     84          	P1IFG &= ~BIT0;		// Clear P1.0 IFG
   \   000040   D2C32300     BIC.B   #0x1, &0x23
     85          }
   \   000044   3C17         POPM.W  #0x4, R15
   \   000046   0013         RETI
   \   000048                REQUIRE SCFQCTL
   \   000048                REQUIRE P1IN
   \   000048                REQUIRE P1IFG

   \                                 In  segment INTVEC, offset 0x28, root
   \                     `??Port1_ISR??INTVEC 40`:
   \   000028   ....         DC16    Port1_ISR

   \                                 In  segment INTVEC, offset 0x34, root
   \                     `??watchdog_timer??INTVEC 52`:
   \   000034   ....         DC16    watchdog_timer
     86          
     87          
     88          
     89          
     90          
     91          
     92          
     93          
     94          
     95          
     96          
     97          
     98          
     99          
    100          
    101          
    102          
    103          
    104          
    105          
    106          
    107          
    108          
    109          
    110          
    111          
    112          
    113          
    114          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   Port1_ISR
      4   main
      4   watchdog_timer


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??Port1_ISR??INTVEC 40
       2  ??watchdog_timer??INTVEC 52
       1  P1IFG
       1  P1IN
       1  P3DIR
       1  P3SEL
      72  Port1_ISR
       1  SCFQCTL
       2  TBCCR4
       2  TBCCTL4
       2  TBCTL
       2  WDTCTL
      40  main
       2  watchdog_timer

 
 40 bytes in segment CODE
 13 bytes in segment DATA16_AN
  4 bytes in segment INTVEC
 74 bytes in segment ISR_CODE
 
 114 bytes of CODE  memory
   0 bytes of CONST memory (+  4 bytes shared)
   0 bytes of DATA  memory (+ 13 bytes shared)

Errors: none
Warnings: none
