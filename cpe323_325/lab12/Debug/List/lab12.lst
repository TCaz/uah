###############################################################################
#
# IAR C/C++ Compiler V6.10.2.50871/W32 for MSP430         25/Nov/2014  14:41:55
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.10
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  D:\uah\cpe323\lab12\lab12.c
#    Command line  =  
#        D:\uah\cpe323\lab12\lab12.c -lCN D:\uah\cpe323\lab12\Debug\List\ -o
#        D:\uah\cpe323\lab12\Debug\Obj\ --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --debug -D__MSP430FG4618__ -e --double=32
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\430\lib\dlib\dl430xlsfn.h" --core=430X --data_model=small -On
#        --multiplier=16 --segment __data16=DATA16 --segment __data20=DATA20
#        --code_model=large
#    List file     =  D:\uah\cpe323\lab12\Debug\List\lab12.lst
#    Object file   =  D:\uah\cpe323\lab12\Debug\Obj\lab12.r43
#
###############################################################################

D:\uah\cpe323\lab12\lab12.c
      1          /***********************************************************************
      2           * Title: LAB 12
      3           * Date Due: Nov 2x
      4           * 
      5           * Description:
      6           * 		This program does stuff
      7           *
      8           * By: Christopher 'ctag' Bero <csb0019@uah.edu>
      9           * Project: https://github.com/ctag/uah
     10           *
     11           * This software is licensed under the GPLv3,
     12           * consult the LICENSE file for more information.
     13           **********************************************************************/
     14          
     15          /*
     16           * Include statements
     17           */
     18          #include <msp430.h> // The *correct* include statement

   \                                 In  segment DATA16_AN, at 0x3
   \   unsigned char volatile IFG2
   \                     IFG2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x52
   \   unsigned char volatile SCFQCTL
   \                     SCFQCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x20
   \   unsigned char const volatile P1IN
   \                     P1IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x24
   \   unsigned char volatile P1IES
   \                     P1IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x25
   \   unsigned char volatile P1IE
   \                     P1IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x29
   \   unsigned char volatile P2OUT
   \                     P2OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2e
   \   unsigned char volatile P2SEL
   \                     P2SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x160
   \   unsigned short volatile TACTL
   \                     TACTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x162
   \   unsigned short volatile TACCTL0
   \                     TACCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x172
   \   unsigned short volatile TACCR0
   \                     TACCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x60
   \   unsigned char volatile UCA0CTL0
   \                     UCA0CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61
   \   unsigned char volatile UCA0CTL1
   \                     UCA0CTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x62
   \   unsigned char volatile UCA0BR0
   \                     UCA0BR0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x63
   \   unsigned char volatile UCA0BR1
   \                     UCA0BR1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x64
   \   unsigned char volatile UCA0MCTL
   \                     UCA0MCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x67
   \   unsigned char volatile UCA0TXBUF
   \                     UCA0TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2
     19          #include <string.h> // For manipulating char[]?, doesn't seem to work with mspgcc :-/
     20          #include <stdio.h>	// For printf functions
     21          #include "gateway.h" // For wireless functions
     22          
     23          /*
     24           * Global variables
     25           */
     26          #define SW1 (0x01&P1IN)	// B1 - P1.0 switch SW1
     27          #define SW2 (0x02&P1IN)	// B2 - P1.1 switch SW2
     28          
     29          #define SERVER_ADDRESS 0x1
     30          #define CLIENT_ADDRESS 0x2
     31          
     32          #define LED2_TOGGLE_COMMAND 0x02
     33          
     34          extern char paTable[];
     35          extern char paTableLen;
     36          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     37          char led2TogglePacket[3];
   \                     led2TogglePacket:
   \   000000                DS8 3

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     38          char timePacket[9];
   \                     timePacket:
   \   000000                DS8 9

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          char rxBuffer[256];
   \                     rxBuffer:
   \   000000                DS8 256

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     40          char len;
   \                     len:
   \   000000                DS8 1
     41          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     42          unsigned long millisec = 0;
   \                     millisec:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     43          short unsigned int timer_on = 0;
   \                     timer_on:
   \   000000                DS8 2
     44          
     45          /*
     46           * Function Definitions
     47           */
     48          

   \                                 In  segment CODE, align 2
     49          void Delay_Debounce(void)
   \                     Delay_Debounce:
     50          {
     51          	//for(int i=0;i<2500;i++);         // POR software delay
     52          	
     53          	// Constant delay debounce
     54              int factor = (SCFQCTL / 30);
   \   000000   5C425200     MOV.B   &0x52, R12
   \   000004   7E401E00     MOV.B   #0x1e, R14
   \   000008   ........     CALLA   #?DivMod8u
   \   00000C   4C4C         MOV.B   R12, R12
     55          	int looper = (20 * factor);
   \   00000E   0F4C         MOV.W   R12, R15
   \   000010   5F06         RLAM.W  #0x2, R15
   \   000012   0E4F         MOV.W   R15, R14
   \   000014   5F06         RLAM.W  #0x2, R15
   \   000016   0F5E         ADD.W   R14, R15
     56          	for (int c = 0; c < looper; c++)
   \   000018   0E43         MOV.W   #0x0, R14
   \                     ??Delay_Debounce_0:
   \   00001A   0E9F         CMP.W   R15, R14
   \   00001C   0334         JGE     ??Delay_Debounce_1
     57          	{ asm("NOP"); }
   \   00001E   0343         NOP
   \   000020   1E53         ADD.W   #0x1, R14
   \   000022   FB3F         JMP     ??Delay_Debounce_0
     58          }
   \                     ??Delay_Debounce_1:
   \   000024   1001         RETA
   \   000026                REQUIRE SCFQCTL
     59          
     60          /*
     61           * Function to initialize ports for interfacing TI CC1100 (TI_CC) 
     62           */

   \                                 In  segment CODE, align 2
     63          void  TI_CC_Initialize()
   \                     TI_CC_Initialize:
     64          {
     65          	TI_CC_LED_PxDIR |= TI_CC_LED1;           // Port 1 LED set to Outputs
   \   000000   E2D32A00     BIS.B   #0x2, &0x2a
     66          	TI_CC_LED_PxOUT |= TI_CC_LED1;           // Initialize, turn on LED1
   \   000004   E2D32900     BIS.B   #0x2, &0x29
     67                  TI_CC_GDO0_PxIES |= TI_CC_GDO0_PIN;
   \   000008   E2D22400     BIS.B   #0x4, &0x24
     68          	TI_CC_GDO0_PxIFG &= ~TI_CC_GDO0_PIN;    // Initialize, clear 
   \   00000C   E2C22300     BIC.B   #0x4, &0x23
     69                                                      // TI_CC_GDO0_PIN bit which is
     70                                                      //set after data packet transfer          
     71          	TI_CC_GDO0_PxIE |= TI_CC_GDO0_PIN;      // Enable interrupt to occur at
   \   000010   E2D22500     BIS.B   #0x4, &0x25
     72                                                      // the end of a data packet
     73          }	// end TI_CC_Initialize (Transmitter version)
   \   000014   1001         RETA
   \   000016                REQUIRE P2DIR
   \   000016                REQUIRE P2OUT
   \   000016                REQUIRE P1IES
   \   000016                REQUIRE P1IFG
   \   000016                REQUIRE P1IE
     74          
     75          /*
     76           * Function to support MSP430 transmitter initialization to support wireless 
     77           * communication  via SPI provided by the TI CC1100 chip which attaches
     78           * to the transmitting TI MSP430 experimenter board.
     79           */

   \                                 In  segment CODE, align 2
     80          void Transmitter_Initialize()
   \                     Transmitter_Initialize:
     81          {  
     82                  Delay_Debounce();
   \   000000   ........     CALLA   #Delay_Debounce
     83          	TI_CC_SPISetup();                       // Initialize SPI port
   \   000004   ........     CALLA   #TI_CC_SPISetup
     84          	TI_CC_PowerupResetCCxxxx();             // Reset CCxxxx
   \   000008   ........     CALLA   #TI_CC_PowerupResetCCxxxx
     85          	writeRFSettings();                      // Write RF settings to config reg
   \   00000C   ........     CALLA   #writeRFSettings
     86          	TI_CC_SPIWriteBurstReg(TI_CCxxx0_PATABLE, paTable, paTableLen); 
   \   000010   5E42....     MOV.B   &paTableLen, R14
   \   000014   3D40....     MOV.W   #paTable, R13
   \   000018   7C403E00     MOV.B   #0x3e, R12
   \   00001C   ........     CALLA   #TI_CC_SPIWriteBurstReg
     87                                                      // Write PATABLE
     88          	TI_CC_Initialize();                     // Initialize CCxxx on port 1.
   \   000020   ........     CALLA   #TI_CC_Initialize
     89          	TI_CC_SPIStrobe(TI_CCxxx0_SRX);         // Initialize CCxxxx in RX mode.
   \   000024   7C403400     MOV.B   #0x34, R12
   \   000028   ........     BRA     #TI_CC_SPIStrobe
     90          }	// end Transmitter_Initialize
     91          
     92          /*
     93           * USART in UART Mode 
     94           */

   \                                 In  segment CODE, align 2
     95          void UART_Initialize(void) 
   \                     UART_Initialize:
     96          {   
     97          	P2SEL |= BIT4+BIT5; // Set UC0TXD and UC0RXD to transmit and receive data   
   \   000000   F2D030002E00 BIS.B   #0x30, &0x2e
     98          	UCA0CTL1 |= BIT0; // Software reset   
   \   000006   D2D36100     BIS.B   #0x1, &0x61
     99          	UCA0CTL0 = 0; // USCI_A0 control register   
   \   00000A   C2436000     MOV.B   #0x0, &0x60
    100          	UCA0CTL1 |= UCSSEL_2; // Clock source SMCLK   
   \   00000E   F2D080006100 BIS.B   #0x80, &0x61
    101          	UCA0BR0=54; // 1048576 Hz / 19200   
   \   000014   F24036006200 MOV.B   #0x36, &0x62
    102          	UCA0BR1=0; //   
   \   00001A   C2436300     MOV.B   #0x0, &0x63
    103          	UCA0MCTL=0x0A; // Modulation   
   \   00001E   F2400A006400 MOV.B   #0xa, &0x64
    104          	UCA0CTL1 &= ~BIT0; // Undo software reset 
   \   000024   D2C36100     BIC.B   #0x1, &0x61
    105          }  
   \   000028   1001         RETA
   \   00002A                REQUIRE P2SEL
   \   00002A                REQUIRE UCA0CTL1
   \   00002A                REQUIRE UCA0CTL0
   \   00002A                REQUIRE UCA0BR0
   \   00002A                REQUIRE UCA0BR1
   \   00002A                REQUIRE UCA0MCTL
    106          
    107          /*
    108           * Write a char to the serial buffer
    109           */

   \                                 In  segment CODE, align 2
    110          void UART_Write(char c) {
   \                     UART_Write:
   \                     ??UART_Write_0:
    111          	while (!(IFG2 & UCA0TXIFG));
   \   000000   E2B30300     BIT.B   #0x2, &0x3
   \   000004   FD2B         JNC     ??UART_Write_0
    112          	UCA0TXBUF = c;
   \   000006   C24C6700     MOV.B   R12, &0x67
    113          } 
   \   00000A   1001         RETA
   \   00000C                REQUIRE IFG2
   \   00000C                REQUIRE UCA0TXBUF
    114          
    115          /*
    116           * Write a static debugging message to serial buffer
    117           */

   \                                 In  segment CODE, align 2
    118          void UART_Toggle_SW2 (void) {
   \                     UART_Toggle_SW2:
   \   000000   3182         SUB.W   #0x8, SP
    119          	char message[8];
    120          	sprintf(message, "Toggling"); // prints string to char
   \   000002   3D40....     MOV.W   #`?<Constant "Toggling">`, R13
   \   000006   0C41         MOV.W   SP, R12
   \   000008   0C53         ADD.W   #0x0, R12
   \   00000A   ........     CALLA   #sprintf
    121          	for(int i=0;i<8;i++) // Send character by character   
   \   00000E   0F43         MOV.W   #0x0, R15
   \                     ??UART_Toggle_SW2_1:
   \   000010   3F92         CMP.W   #0x8, R15
   \   000012   0934         JGE     ??UART_Toggle_SW2_2
    122          	{     
    123          		while (!(IFG2 & UCA0TXIFG));     
   \                     ??UART_Toggle_SW2_0:
   \   000014   E2B30300     BIT.B   #0x2, &0x3
   \   000018   FD2B         JNC     ??UART_Toggle_SW2_0
    124          		UCA0TXBUF = message[i];   
   \   00001A   0E4F         MOV.W   R15, R14
   \   00001C   0E51         ADD.W   SP, R14
   \   00001E   E24E6700     MOV.B   @R14, &0x67
    125          	}
   \   000022   1F53         ADD.W   #0x1, R15
   \   000024   F53F         JMP     ??UART_Toggle_SW2_1
    126          	UART_Write('\r');
   \                     ??UART_Toggle_SW2_2:
   \   000026   7C400D00     MOV.B   #0xd, R12
   \   00002A   ........     CALLA   #UART_Write
    127          	UART_Write('\n');
   \   00002E   7C400A00     MOV.B   #0xa, R12
   \   000032   ........     CALLA   #UART_Write
    128          }
   \   000036   3152         ADD.W   #0x8, SP
   \   000038   1001         RETA
   \   00003A                REQUIRE IFG2
   \   00003A                REQUIRE UCA0TXBUF
    129          

   \                                 In  segment CODE, align 2
    130          void main(void)
   \                     main:
    131          {
   \   000000   1B15         PUSHM.W #0x2, R11
    132          	WDTCTL = (WDTPW|WDTHOLD); // halt watchdog
   \   000002   B240805A2001 MOV.W   #0x5a80, &0x120
    133          	
    134          	// Setup Timer_A, leave halted
    135          	//TACTL = TASSEL_2 + ID_3 + MC_1; // Select smclk/8 and up mode
    136          	// To start: TACTL |= MC_1;
    137          	//TACCR0 = 131; // 1ms interval   
    138          	//TACCTL0 = CCIE; // Capture/compare interrupt enable 
    139          	
    140          	_EINT();	// Enable interrupts
   \   000008   32D2         EINT
    141          
    142          	UART_Initialize(); // Configure serial UART registers
   \   00000A   ........     CALLA   #UART_Initialize
    143          	
    144          	P1IE |= 0x03;		// Enable P1 interrupt for bit 0 and 1
   \   00000E   F2D003002500 BIS.B   #0x3, &0x25
    145          	P1IES |= 0x03;		// Set interrupt call to falling edge
   \   000014   F2D003002400 BIS.B   #0x3, &0x24
    146          	P1IFG &= ~(0x03);	// Clear interrupt flags
   \   00001A   F2F0FC002300 AND.B   #0xfc, &0x23
    147          	P2DIR |= 0x06;		// Set P2.1 and P2.2 to output (0000_0110) 
   \   000020   F2D006002A00 BIS.B   #0x6, &0x2a
    148          	P2OUT = 0x02;		// Set P2OUT to 0000_0010b
   \   000026   E2432900     MOV.B   #0x2, &0x29
    149          	Transmitter_Initialize();      
   \   00002A   ........     CALLA   #Transmitter_Initialize
    150          
    151          	// Go ahead and set up the packet for toggleing LED2 on the server board
    152          	// as it will not change.
    153          	led2TogglePacket[PLENGTHINDEX] = PSIZE - 1;  
   \   00002E   E243....     MOV.B   #0x2, &led2TogglePacket
    154          	led2TogglePacket[PADDRINDEX] = SERVER_ADDRESS;
   \   000032   D243....     MOV.B   #0x1, &led2TogglePacket + 1
    155          	led2TogglePacket[PDATAINDEX] = LED2_TOGGLE_COMMAND;
   \   000036   E243....     MOV.B   #0x2, &led2TogglePacket + 2
    156          	
    157          	// Setup timePacket
    158          	timePacket[0] = 5;
   \   00003A   F2400500.... MOV.B   #0x5, &timePacket
    159          	timePacket[1] = 0x1;
   \   000040   D243....     MOV.B   #0x1, &timePacket + 1
    160          	
    161          	while (1)
    162          	{
    163          		//_BIS_SR(LPM3_bits + GIE);	// Enter LPM0, enable interrupts
    164          	  
    165          	  	if (SW1 != 0 && timer_on == 1) {
   \                     ??main_2:
   \   000044   D2B32000     BIT.B   #0x1, &0x20
   \   000048   3428         JNC     ??main_3
   \   00004A   9293....     CMP.W   #0x1, &timer_on
   \   00004E   3120         JNE     ??main_3
    166          		TACTL &= ~MC_1;
   \   000050   B2C010006001 BIC.W   #0x10, &0x160
    167          		char * timePointer = (char *)&millisec;
   \   000056   3A40....     MOV.W   #millisec, R10
    168          		
    169          		int i = 0;
   \   00005A   0B43         MOV.W   #0x0, R11
    170          		while (i < 9) {
   \                     ??main_0:
   \   00005C   3B900900     CMP.W   #0x9, R11
   \   000060   0D34         JGE     ??main_4
    171          			UART_Write(timePointer[i] * 4);
   \   000062   0F4A         MOV.W   R10, R15
   \   000064   0F5B         ADD.W   R11, R15
   \   000066   6C4F         MOV.B   @R15, R12
   \   000068                RPT     #0x2
   \   000068   41184C5C     RLAX.B  R12
   \   00006C   ........     CALLA   #UART_Write
    172          			UART_Write('_');
   \   000070   7C405F00     MOV.B   #0x5f, R12
   \   000074   ........     CALLA   #UART_Write
    173          			i++;
   \   000078   1B53         ADD.W   #0x1, R11
   \   00007A   F03F         JMP     ??main_0
    174          		}
    175          		UART_Write('\n');
   \                     ??main_4:
   \   00007C   7C400A00     MOV.B   #0xa, R12
   \   000080   ........     CALLA   #UART_Write
    176          		UART_Write('\r');
   \   000084   7C400D00     MOV.B   #0xd, R12
   \   000088   ........     CALLA   #UART_Write
    177          		
    178          		for (int c = 0; c < 7; c++) {
   \   00008C   0F43         MOV.W   #0x0, R15
   \                     ??main_1:
   \   00008E   3F900700     CMP.W   #0x7, R15
   \   000092   0634         JGE     ??main_5
    179          			timePacket[c+2] = timePointer[c];
   \   000094   0E4A         MOV.W   R10, R14
   \   000096   0E5F         ADD.W   R15, R14
   \   000098   EF4E....     MOV.B   @R14, timePacket + 2(R15)
    180          		}
   \   00009C   1F53         ADD.W   #0x1, R15
   \   00009E   F73F         JMP     ??main_1
    181          		
    182          		RFSendPacket(timePacket, 9);
   \                     ??main_5:
   \   0000A0   7D400900     MOV.B   #0x9, R13
   \   0000A4   3C40....     MOV.W   #timePacket, R12
   \   0000A8   ........     CALLA   #RFSendPacket
    183          		timer_on = 0;
   \   0000AC   8243....     MOV.W   #0x0, &timer_on
   \   0000B0   C93F         JMP     ??main_2
    184          		}
    185          		else if (timer_on == 0) {
   \                     ??main_3:
   \   0000B2   8293....     CMP.W   #0x0, &timer_on
   \   0000B6   C623         JNE     ??main_2
    186          		  TACTL = 0x00;
   \   0000B8   82436001     MOV.W   #0x0, &0x160
    187          		  P2OUT &= ~0x04;
   \   0000BC   E2C22900     BIC.B   #0x4, &0x29
   \   0000C0   C13F         JMP     ??main_2
   \   0000C2                REQUIRE WDTCTL
   \   0000C2                REQUIRE P1IE
   \   0000C2                REQUIRE P1IES
   \   0000C2                REQUIRE P1IFG
   \   0000C2                REQUIRE P2DIR
   \   0000C2                REQUIRE P2OUT
   \   0000C2                REQUIRE P1IN
   \   0000C2                REQUIRE TACTL
    188          		}
    189          	}
    190          }
    191          
    192          /*
    193           * Timer_A interrupt service routine
    194           */
    195          #pragma vector=TIMERA0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    196          __interrupt void TIMERA_ISA(void)
   \                     TIMERA_ISA:
    197          {
    198          	millisec++;
   \   000000   9253....     ADD.W   #0x1, &millisec
   \   000004   8263....     ADDC.W  #0x0, &millisec + 2
    199          	P2OUT ^= 0x04;
   \   000008   E2E22900     XOR.B   #0x4, &0x29
    200          	//_BIC_SR_IRQ(LPM0_bits); // Clear LPM0 bits from 0(SR)
    201          }
   \   00000C   0013         RETI
   \   00000E                REQUIRE P2OUT
    202          
    203          /*
    204           * Port 1 interrupt service routine
    205           */
    206          #pragma vector = PORT1_VECTOR

   \                                 In  segment ISR_CODE, align 2
    207          __interrupt void Port1_ISR (void)
   \                     Port1_ISR:
    208          {
   \   000000   5F15         PUSHM.W #0x6, R15
    209            Delay_Debounce();
   \   000002   ........     CALLA   #Delay_Debounce
    210          
    211          	if (((SW1) == 0) && ((SW2) != 0)) // SW1 is pressed
   \   000006   D2B32000     BIT.B   #0x1, &0x20
   \   00000A   132C         JC      ??Port1_ISR_1
   \   00000C   E2B32000     BIT.B   #0x2, &0x20
   \   000010   1028         JNC     ??Port1_ISR_1
    212          	{
    213          		millisec = 0;
   \   000012   8243....     MOV.W   #0x0, &millisec
   \   000016   8243....     MOV.W   #0x0, &millisec + 2
    214          		timer_on = 1;
   \   00001A   9243....     MOV.W   #0x1, &timer_on
    215          		
    216          		// Setup Timer_A, leave halted
    217          		TACTL = TASSEL_2 + ID_3 + MC_1; // Select smclk/8 and up mode
   \   00001E   B240D0026001 MOV.W   #0x2d0, &0x160
    218          		TACCR0 = 131; // 1ms interval   
   \   000024   B24083007201 MOV.W   #0x83, &0x172
    219          		TACCTL0 = CCIE; // Capture/compare interrupt enable 
   \   00002A   B24010006201 MOV.W   #0x10, &0x162
   \   000030   0C3C         JMP     ??Port1_ISR_2
    220          		
    221          	} else if (((SW2) == 0) && ((SW1) != 0)) // SW2 is pressed
   \                     ??Port1_ISR_1:
   \   000032   E2B32000     BIT.B   #0x2, &0x20
   \   000036   092C         JC      ??Port1_ISR_2
   \   000038   D2B32000     BIT.B   #0x1, &0x20
   \   00003C   0628         JNC     ??Port1_ISR_2
    222          	{
    223          		RFSendPacket(led2TogglePacket, PSIZE);
   \   00003E   7D400300     MOV.B   #0x3, R13
   \   000042   3C40....     MOV.W   #led2TogglePacket, R12
   \   000046   ........     CALLA   #RFSendPacket
    224          	}
    225          	
    226          	if(P1IFG & TI_CC_GDO0_PIN)              // Command received from RF RX active
   \                     ??Port1_ISR_2:
   \   00004A   E2B22300     BIT.B   #0x4, &0x23
   \   00004E   2428         JNC     ??Port1_ISR_3
    227               {   
    228                  if( RFReceivePacket(rxBuffer,&len))   // check if packet is received       
   \   000050   3D40....     MOV.W   #len, R13
   \   000054   3C40....     MOV.W   #rxBuffer, R12
   \   000058   ........     CALLA   #RFReceivePacket
   \   00005C   4C93         CMP.B   #0x0, R12
   \   00005E   1A24         JEQ     ??Port1_ISR_4
    229          	{
    230          			
    231                      if(rxBuffer[0] == CLIENT_ADDRESS) // Make sure this message is intended for the client
   \   000060   E293....     CMP.B   #0x2, &rxBuffer
   \   000064   1720         JNE     ??Port1_ISR_4
    232                      {
    233                    
    234                        //if server sends LED2 toggle command, toggle LED2
    235                        if(rxBuffer[1] == LED2_TOGGLE_COMMAND && len==2) //Messages longer than length 2 should be treated differently
   \   000066   E293....     CMP.B   #0x2, &rxBuffer + 1
   \   00006A   0620         JNE     ??Port1_ISR_5
   \   00006C   E293....     CMP.B   #0x2, &len
   \   000070   0320         JNE     ??Port1_ISR_5
    236                        {
    237                            P2OUT ^= 0x02;
   \   000072   E2E32900     XOR.B   #0x2, &0x29
   \   000076   0E3C         JMP     ??Port1_ISR_4
    238                            //UART_Toggle_SW2();
    239                        } 
    240                        else { // Send to UART
    241          			  int i = 1;
   \                     ??Port1_ISR_5:
   \   000078   1A43         MOV.W   #0x1, R10
    242          			  while (rxBuffer[i] != '\0')
   \                     ??Port1_ISR_0:
   \   00007A   CA93....     CMP.B   #0x0, rxBuffer(R10)
   \   00007E   0A24         JEQ     ??Port1_ISR_4
    243          			  {
    244          				  UART_Write(rxBuffer[i]);
   \   000080   5C4A....     MOV.B   rxBuffer(R10), R12
   \   000084   ........     CALLA   #UART_Write
    245          				  i++;
   \   000088   1A53         ADD.W   #0x1, R10
    246          				  if (i > len) {
   \   00008A   5F42....     MOV.B   &len, R15
   \   00008E   4F4F         MOV.B   R15, R15
   \   000090   0F9A         CMP.W   R10, R15
   \   000092   F337         JGE     ??Port1_ISR_0
    247          					  break;
    248          				  }
    249          			  }
    250                      }
    251                        
    252                      }
    253                  }
    254          	P1IFG &= ~(TI_CC_GDO0_PIN); // reset of TI_CC_GDO0_PIN bit which is set after data packet transfer  
   \                     ??Port1_ISR_4:
   \   000094   E2C22300     BIC.B   #0x4, &0x23
    255          	
    256              }
    257          
    258          	P1IFG &= ~BIT1;		// Clear P1.1 IFG
   \                     ??Port1_ISR_3:
   \   000098   E2C32300     BIC.B   #0x2, &0x23
    259          	P1IFG &= ~BIT0;		// Clear P1.0 IFG
   \   00009C   D2C32300     BIC.B   #0x1, &0x23
    260          }
   \   0000A0   5A17         POPM.W  #0x6, R15
   \   0000A2   0013         RETI
   \   0000A4                REQUIRE P1IN
   \   0000A4                REQUIRE TACTL
   \   0000A4                REQUIRE TACCR0
   \   0000A4                REQUIRE TACCTL0
   \   0000A4                REQUIRE P1IFG
   \   0000A4                REQUIRE P2OUT

   \                                 In  segment INTVEC, offset 0x28, root
   \                     `??Port1_ISR??INTVEC 40`:
   \   000028   ....         DC16    Port1_ISR

   \                                 In  segment INTVEC, offset 0x2c, root
   \                     `??TIMERA_ISA??INTVEC 44`:
   \   00002C   ....         DC16    TIMERA_ISA

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Toggling">`:
   \   000000   546F67676C69 DC8 "Toggling"
   \            6E6700      
    261          
    262          
    263          
    264          
    265          
    266          
    267          
    268          
    269          
    270          
    271          
    272          
    273          
    274          
    275          
    276          
    277          
    278          
    279          
    280          
    281          
    282          
    283          
    284          
    285          
    286          
    287          
    288          
    289          
    290          
    291          
    292          
    293          
    294          
    295          
    296          
    297          
    298          
    299          
    300          
    301          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   Delay_Debounce
     16   Port1_ISR
       16   -> Delay_Debounce
       16   -> RFReceivePacket
       16   -> RFSendPacket
       16   -> UART_Write
      4   TIMERA_ISA
      4   TI_CC_Initialize
      4   Transmitter_Initialize
        4   -> Delay_Debounce
        4   -> TI_CC_Initialize
        4   -> TI_CC_PowerupResetCCxxxx
        4   -> TI_CC_SPISetup
        4   -> TI_CC_SPIStrobe
        4   -> TI_CC_SPIWriteBurstReg
        4   -> writeRFSettings
      4   UART_Initialize
     12   UART_Toggle_SW2
       12   -> UART_Write
       12   -> sprintf
      4   UART_Write
      8   main
        8   -> RFSendPacket
        8   -> Transmitter_Initialize
        8   -> UART_Initialize
        8   -> UART_Write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "Toggling">
       2  ??Port1_ISR??INTVEC 40
       2  ??TIMERA_ISA??INTVEC 44
      38  Delay_Debounce
       1  IFG2
       1  P1IE
       1  P1IES
       1  P1IFG
       1  P1IN
       1  P2DIR
       1  P2OUT
       1  P2SEL
     164  Port1_ISR
       1  SCFQCTL
       2  TACCR0
       2  TACCTL0
       2  TACTL
      14  TIMERA_ISA
      22  TI_CC_Initialize
      44  Transmitter_Initialize
      42  UART_Initialize
      58  UART_Toggle_SW2
      12  UART_Write
       1  UCA0BR0
       1  UCA0BR1
       1  UCA0CTL0
       1  UCA0CTL1
       1  UCA0MCTL
       1  UCA0TXBUF
       2  WDTCTL
       3  led2TogglePacket
       1  len
     194  main
       4  millisec
     256  rxBuffer
       9  timePacket
       2  timer_on

 
 410 bytes in segment CODE
  23 bytes in segment DATA16_AN
   9 bytes in segment DATA16_C
 275 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
 178 bytes in segment ISR_CODE
 
 588 bytes of CODE  memory
   9 bytes of CONST memory (+  4 bytes shared)
 275 bytes of DATA  memory (+ 23 bytes shared)

Errors: none
Warnings: none
